In this sprint, my main focus was backend development and integrating the frontend and backend seamlessly to create a functional, real-time coding interface. I set up Judge0 as the core backend for code execution, allowing users to write and run code directly within the application. I integrated this backend with a React-based frontend, using the Monaco Editor for a flexible and interactive user interface. By leveraging Flask and Socket.IO, I enabled smooth, real-time communication between the frontend and backend, which greatly enhanced the responsiveness of the application.

One of the main challenges I encountered was managing payload formatting and handling asynchronous responses to ensure smooth communication between the frontend and Judge0. Debugging and troubleshooting ESLint and cache issues were also significant tasks. While upgrading dependencies, particularly React and other libraries, I ran into recurring permission and compilation issues related to `.eslintcache`. I resolved this by adjusting file permissions and clearing the cache, which restored the applicationâ€™s build stability. These challenges were instrumental in helping me develop stronger debugging skills and experience in managing node dependencies.

This sprint taught me a lot about API integration and backend-to-frontend communication, especially in managing real-time interactions using Flask and Socket.IO. Working with Monaco Editor in React also gave me insight into handling editor-specific callbacks and component states, enhancing my understanding of frontend design and interactivity. Additionally, I gained hands-on experience in troubleshooting dependency and ESLint errors, which helped refine my problem-solving approach.

Reflecting on areas for improvement, I realized the importance of better code modularization from the start. Separating functionalities into distinct, reusable components (such as input fields, editor, and output display) would reduce complexity and make the codebase more manageable, minimizing the need for major refactoring later. In future sprints, I plan to improve component organization and increase documentation, which will enhance clarity and make the application easier to maintain. Adding error-handling layers for user inputs will also improve the overall user experience, making the interface more resilient and user-friendly.
